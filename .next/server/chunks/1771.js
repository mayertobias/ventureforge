exports.id=1771,exports.ids=[1771],exports.modules={12909:(a,b,c)=>{"use strict";c.d(b,{N:()=>f});var d=c(36344),e=c(31183);let f={providers:[(0,d.A)({clientId:process.env.GOOGLE_CLIENT_ID,clientSecret:process.env.GOOGLE_CLIENT_SECRET})],callbacks:{async signIn({user:a,account:b,profile:c}){if(b?.provider==="google")try{await e.z.user.findUnique({where:{email:a.email}})||await e.z.user.create({data:{email:a.email,name:a.name,image:a.image,credits:100}})}catch(a){return console.error("Error creating user:",a),!1}return!0},async session({session:a,token:b}){if(a?.user?.email){let b=await e.z.user.findUnique({where:{email:a.user.email}});b&&a.user&&(a.user.id=b.id)}return a},jwt:async({user:a,token:b})=>b},session:{strategy:"jwt"},secret:process.env.NEXTAUTH_SECRET}},31183:(a,b,c)=>{"use strict";c.d(b,{z:()=>e});var d=c(96330);let e=globalThis.prisma??new d.PrismaClient},74339:(a,b,c)=>{"use strict";c.d(b,{R:()=>f});var d=c(31183);let e=new Map;class f{static{this.cleanupInterval=null}static initialize(){console.log("SessionStorageService initialized for serverless environment")}static async createProjectSession(a,b,c=!1,e,f){let g=f||(c?`persistent_${Date.now()}_${Math.random().toString(36).substr(2,9)}`:`session_${Date.now()}_${Math.random().toString(36).substr(2,9)}`),h=new Date,i=new Date(c?h.getTime()+2592e6:h.getTime()+864e5);try{return await d.z.project.upsert({where:{id:g},update:{name:b,expiresAt:e||i,ideaOutput:void 0,researchOutput:void 0,blueprintOutput:void 0,financialOutput:void 0,pitchOutput:void 0,gtmOutput:void 0},create:{id:g,name:b,userId:a,storageMode:c?"PERSISTENT":"MEMORY_ONLY",expiresAt:e||i}}),console.log(`Created ${c?"persistent":"session"} project: ${g} for user: ${a}`),g}catch(a){throw console.error("Failed to create project session:",a),Error("Failed to create project session")}}static async getProjectSession(a,b){try{let c=await d.z.project.findFirst({where:{id:a,userId:b}});if(!c)return null;if(c.expiresAt&&c.expiresAt<new Date)return await this.deleteProjectSession(a,b),null;let f="MEMORY_ONLY"===c.storageMode;if(console.log(`[PRIVACY] Getting project ${a} - Mode: ${c.storageMode}`),!f)return console.log(`[PRIVACY] Retrieved PERSISTENT project ${a} from database`),{id:c.id,userId:c.userId,name:c.name,createdAt:c.createdAt,lastAccessed:new Date,expiresAt:c.expiresAt||new Date(Date.now()+864e5),data:{ideaOutput:c.ideaOutput,researchOutput:c.researchOutput,blueprintOutput:c.blueprintOutput,financialOutput:c.financialOutput,pitchOutput:c.pitchOutput,gtmOutput:c.gtmOutput}};{let d=`${a}_${b}`,f=e.get(d);if(f)return f.lastAccessed=new Date,console.log(`[PRIVACY] Retrieved MEMORY_ONLY project ${a} from memory`),f;return console.log(`[PRIVACY] MEMORY_ONLY project ${a} not found in memory, returning empty shell`),{id:c.id,userId:c.userId,name:c.name,createdAt:c.createdAt,lastAccessed:new Date,expiresAt:c.expiresAt||new Date(Date.now()+864e5),data:{}}}}catch(a){return console.error("Failed to get project session:",a),null}}static async updateProjectData(a,b,c,f){try{let g=await d.z.project.findFirst({where:{id:a,userId:b}});if(!g)return console.error(`Project ${a} not found for user ${b}`),!1;if(g.expiresAt&&g.expiresAt<new Date)return console.error(`Project ${a} has expired`),await this.deleteProjectSession(a,b),!1;let h="MEMORY_ONLY"===g.storageMode;if(console.log(`[PRIVACY] Updating ${c} for project ${a} - Mode: ${g.storageMode}`),!h)return await d.z.project.update({where:{id:a},data:{[c]:f}}),console.log(`[PRIVACY] Stored ${c} in database for PERSISTENT project ${a}`),!0;{let h=`${a}_${b}`,i=e.get(h);i||(i={id:g.id,userId:g.userId,name:g.name,createdAt:g.createdAt,lastAccessed:new Date,expiresAt:g.expiresAt||new Date(Date.now()+864e5),data:{}}),i.data[c]=f,i.lastAccessed=new Date,e.set(h,i);let j={};return["ideaOutput","researchOutput","blueprintOutput","financialOutput","pitchOutput","gtmOutput"].includes(c)&&(j[c]=null),Object.keys(j).length>0&&await d.z.project.update({where:{id:a},data:j}),console.log(`[PRIVACY] Stored ${c} in memory for MEMORY_ONLY project ${a}`),!0}}catch(b){return console.error(`Failed to update project data for ${a}:`,b),!1}}static async getUserProjectSessions(a){try{return(await d.z.project.findMany({where:{userId:a,expiresAt:{gt:new Date}},orderBy:{updatedAt:"desc"}})).map(b=>{if("MEMORY_ONLY"!==b.storageMode)return{id:b.id,userId:b.userId,name:b.name,createdAt:b.createdAt,lastAccessed:b.updatedAt,expiresAt:b.expiresAt||new Date(Date.now()+864e5),data:{ideaOutput:b.ideaOutput,researchOutput:b.researchOutput,blueprintOutput:b.blueprintOutput,financialOutput:b.financialOutput,pitchOutput:b.pitchOutput,gtmOutput:b.gtmOutput}};{let c=`${b.id}_${a}`,d=e.get(c);return{id:b.id,userId:b.userId,name:b.name,createdAt:b.createdAt,lastAccessed:b.updatedAt,expiresAt:b.expiresAt||new Date(Date.now()+864e5),data:d?.data||{}}}})}catch(a){return console.error("Failed to get user project sessions:",a),[]}}static async deleteProjectSession(a,b){try{let c=`${a}_${b}`;if(e.delete(c),(await d.z.project.deleteMany({where:{id:a,userId:b}})).count>0)return console.log(`[PRIVACY] Deleted project: ${a} for user: ${b} (memory and database)`),!0;return!1}catch(b){return console.error(`Failed to delete project session ${a}:`,b),!1}}static async exportAndDelete(a,b){try{let c=await this.getProjectSession(a,b);if(!c)return null;let d=JSON.parse(JSON.stringify(c));return await this.deleteProjectSession(a,b),console.log(`[PRIVACY] Exported and deleted project: ${a} for user: ${b}`),d}catch(b){return console.error(`Failed to export and delete project ${a}:`,b),null}}static async cleanupExpiredSessions(){try{for(let a of(await d.z.project.findMany({where:{expiresAt:{lt:new Date}},select:{id:!0,userId:!0}}))){let b=`${a.id}_${a.userId}`;e.delete(b)}let a=await d.z.project.deleteMany({where:{expiresAt:{lt:new Date}}});return a.count>0&&console.log(`[PRIVACY] Cleaned up ${a.count} expired projects (memory and database)`),a.count}catch(a){return console.error("Failed to cleanup expired sessions:",a),0}}static async extendSession(a,b,c=2){try{let e=await d.z.project.findFirst({where:{id:a,userId:b}});if(!e)return!1;return await d.z.project.update({where:{id:a},data:{expiresAt:new Date((e.expiresAt||new Date).getTime()+60*c*6e4)}}),!0}catch(b){return console.error(`Failed to extend session ${a}:`,b),!1}}static async getStats(){try{let a=new Date,[b,c,f,g]=await Promise.all([d.z.project.count(),d.z.project.count({where:{expiresAt:{gt:a}}}),d.z.project.count({where:{expiresAt:{lte:a}}}),d.z.project.count({where:{storageMode:"MEMORY_ONLY",expiresAt:{gt:a}}})]);return{total:b,active:c,expired:f,memoryOnly:g,persistent:c-g,memoryStorageSize:e.size,memoryUsage:process.memoryUsage()}}catch(a){return console.error("Failed to get session stats:",a),{total:0,active:0,expired:0,memoryOnly:0,persistent:0,memoryStorageSize:0,memoryUsage:process.memoryUsage()}}}static async cleanupOrphanedMemory(){try{let a=0,b=new Set;for(let c of((await d.z.project.findMany({where:{expiresAt:{gt:new Date}},select:{id:!0,userId:!0}})).forEach(a=>{b.add(`${a.id}_${a.userId}`)}),Array.from(e.keys())))!b.has(c)&&(e.delete(c),a++);return a>0&&console.log(`[PRIVACY] Cleaned up ${a} orphaned memory entries`),a}catch(a){return console.error("Failed to cleanup orphaned memory:",a),0}}static getPrivacyNotice(){return`
PRIVACY NOTICE - Memory-Only Storage:

PROS:
- Ultimate privacy: AI responses never touch database
- Zero persistence of sensitive business data
- Automatic cleanup when function ends

LIMITATIONS (Serverless Environment):
- Data lost if serverless function restarts
- Limited to single function execution context
- Requires immediate export after generation

RECOMMENDATION:
For maximum privacy: Generate → Export → Delete immediately
For reliability: Use PERSISTENT mode with understanding that data is stored securely but retrievably
`}}f.initialize()},78335:()=>{},96487:()=>{}};